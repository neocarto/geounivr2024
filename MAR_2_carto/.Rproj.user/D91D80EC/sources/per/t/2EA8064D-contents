---
title: "GEO UNIV'R Tunisie 2024"
subtitle: "Faire des cartes th√©matiques avec R"
date: "`r Sys.Date()`"
author: "Nicolas Lambert, Elina Marveaux, Ronan Ysebaert"
format:
  html:
    embed-resources: true
    theme: yeti
    smooth-scroll: true
    fontsize: 0.9em
    toc: true
editor_options: 
  chunk_output_type: console
---

![](./img/contourlines.png)

::: {.callout-note}
Ce support est tr√®s largement inspir√© du manuel [`Cartographie avec R`](https://rcarto.github.io/cartographie_avec_r/) r√©alis√© par Timoth√©e Giraud et Hugues P√©cout. Et on les en remercie chalereusement üôè
:::

## Pakages utilis√©s dans cette session.

- `sf`
- `mapsf`
- `cartogram` (facultatif)
- `leaflet` (facultatif)
- `mapview` (facultatif)

Si vous n'avez pas ces packages, vous pouvez les installer en executant la ligne suivante dans la console.

```{r}
#| eval: false
install.packages(c('sf', 'mapsf', 'cartogram', 'leaflet', 'mapview'))
```

## Import et mise en forme des donn√©es

Dans cette s√©quence, nous travaillons √† l'√©chelle des pays africains. Les donn√©es statistiques sont issues de la base de donn√©e de la banque mondiale.

1 - Import des g√©om√©tries

```{r}
#| output: false
library("sf")
```

On dispose d'un fichier geipackage contenant plusieurs g√©om√©tries

```{r}
st_layers("data/afrique.gpkg")
```

On importe la couche correspondant aux pays africains et on la reprojette en projection Pseudo-Mercator.

```{r}
#| output: false
geom <- st_transform(st_read("data/afrique.gpkg", layer = "africa"),"epsg:3857")
```

::: {.callout-note collapse="true"}

## Contenu du Spatial*DataFrame

```{r}
#| echo: false
head(geom,4)
```

:::

2 - Import des donn√©es statistiques issues de la banque mondiale.

```{r}
#| output: false
data <- read.csv("data/worldbank_africa.csv")
```

::: {.callout-note collapse="true"}

## Liste des variables disponibles

```{r}
#| echo: false
meta <- read.csv("data/worldbank_africa_meta.csv")
meta[,c("id", "type","description")]
```

:::

3 - Jointure

```{r}
#| output: false
africa <-  merge(
  x = geom[,"ISO3"],  
  y = data,  
  by.x = "ISO3",
  by.y = "id",
  all.x = TRUE   
)
```

Et quelques couches additionnelles

```{r}
#| echo: true
#| output: false

world <- st_transform(st_read("data/afrique.gpkg", layer = "world"),"epsg:3857")
places <- st_transform(st_read("data/afrique.gpkg", layer = "ne_10m_populated_places"),"epsg:3857")
rail <- st_transform(st_read("data/afrique.gpkg", layer = "ne_10m_railroads"),"epsg:3857")
roads <- st_transform(st_read("data/afrique.gpkg", layer = "ne_10m_roads"),"epsg:3857")



```

Le tout est t√©l√©chargeable [ici](). // TODO

# 1 - cartographie avec `sf`

Gr√¢ce au package `sf`, la fonction `plot()` appliqu√©e √† un Spatial*DataFrame permet de l'afficher comme n'importe quel graphique.

### Comportement par defaut

Par defaut, la fonction renvoie une image pouvant contenir jusqu'√† 10 cartes, chaque carte correspondant √† une colonne. 

```{r}
#| warning: false
plot(africa)
```

Si il y a plus de 10 colonnes dans le jeu de donn√©es, alors on ajoute la param√®tre `max.plot = ncol(africa) - 1` (le nombre de colonnes total moins la colonne de g√©ometries).

```{r}
plot(africa, max.plot = ncol(africa) - 1)
```

On per√ßoit que les couleurs ne sont pas choisies totalement au hasard. Nous verrons un peu plus tard comme cela fonctionne. 

Si on souhaite afficher simplement les g√©om√©tries, on utilise la fonction `st_geometry()`

```{r}
#| warning: false
plot(st_geometry(africa))
```

Ou alors, en s√©lectionnant le champ contenant les g√©om√©tries.

```{r}
#| warning: false
plot(africa$geometry)
```

### Marges en emprise

Dans les affichages pr√©c√©dents, on constate qu'il y a beaucoup d'espace perdu autour de la carte. On peut modifier les marges en modifiant les parametres graphiques. 



```{r}
par(mar = c(0, 0, 0, 0),  xaxs='i', yaxs='i', bg = "#F1F3F5") # c(bottom, left, top, right))
plot(st_geometry(africa))
```

Il est √©galement possible de modifier la taille des figures. Soit dans le yaml en haut du document. Soit directement dans le chunk.

Ici, on d√©termine le bon ratio entre la hauteur et la largeur.

```{r}
bb <- st_bbox(africa)
ratio <- (bb$xmax - bb$xmin) / (bb$ymax - bb$ymin) 
height <- 6
width <- height * ratio
width
```

Puis on √©crit

~~~r
#| fig-heigth: 6
#| fig-width: 6.36
~~~


```{r}
#| fig-height: 6
#| fig-width: 6.36
par(mar = c(0, 0, 0, 0), bg = "#F1F3F5", xaxs='i', yaxs='i')
plot(st_geometry(africa))
```

Enfin, notez qu'avec `xlim` et `ylim`, vous pouvez cadrer la carte sur une emprise particuli√®re. Par exemple ici, on affiche le fond de carte du monde mais uniquement avec l'emprise de l'Afrique.

```{r}
par(mar = c(0, 0, 0, 0), xaxs='i', yaxs='i')
bb <- st_bbox(africa)
plot(st_geometry(world), xlim = c(bb$xmin, bb$xmax), ylim = c(bb$ymin, bb$ymax))
```

### Param√©trer le style

De nombreux param√®tres pertmettent de personnaliser le style de la carte. Nous en citons ici quelques exemples.

- Couleur de fond : `col`
- Couleur de contour : `border`
- Epaisseur des trac√©s : `lwd`

```{r}
#| fig-height: 6
#| fig-width: 6.36
par(mar = c(0, 0, 0, 0), bg = "#F1F3F5", xaxs='i', yaxs='i')
plot(st_geometry(africa), col = "#5b89a3", border = "white", lwd = 0.5)
```

::: {.callout-tip collapse=true}
NB : Il y a 657 noms de couleurs disponibles dans R. Pour les afficher, vous pouvez taper `colors()`

```{r}
cols <- colors()
head(cols, 20)
```
:::

Avec `lty`, on peut √©galement changer le type de traits

<img src = "./img/lty.png" width = "200px"></img>

```{r}
#| fig-height: 6
#| fig-width: 6.36
par(mar = c(0, 0, 0, 0), bg = "#F1F3F5", xaxs='i', yaxs='i')
plot(st_geometry(roads), lty = 3)
```

Avec `pch`, on peut choisir le s de symbole. Avec `cex`, on determine sa taille.

<img src = "./img/pch.png" width = "300px"></img>

```{r}
#| warning: false
#| fig-height: 6
#| fig-width: 6.36
par(mar = c(0, 0, 0, 0), bg = "#F1F3F5", xaxs='i', yaxs='i')
plot(st_geometry(places), pch = 17, col = "red", cex = 1)
```

### Supperposer des couches

Pour supproposer des couches, vous pouvez simplement utiliser le param√®tre `add = TRUE` (sous reserve que les couches soient dans le m√™me syst√®me de coordonn√©es)

```{r}
#| fig-height: 6
#| fig-width: 6.36
par(mar = c(0, 0, 0, 0), bg = "#F1F3F5")
plot(st_geometry(africa), col = "#5b89a3", border = "white", lwd = 0.5)
plot(st_geometry(roads), col = "red", add = TRUE)
plot(st_geometry(places), pch = 19, col = 'black', cex = 0.5, add = TRUE)
```


### Autres √©l√©ments

Il est possible d'ajouter d'autres √©l√©ments √† la mise en page.

- Les axes : `axes = TRUE/FALSE`
- Graticule : `graticule = TRUE`
- Titre = `main = "Hello"`

Par exemple :

```{r}
#| warning: false
#| fig-height: 6
#| fig-width: 6.36
par(mar = c(0, 0, 2, 0))
plot(st_geometry(africa), col= "white", axes = TRUE, graticule = TRUE, main = "Hello")
```

## Effet d'ombrage

Avec R, il est ais√© de translater une g√©o√©m√©trie pour cr√©er un effet d'ombrage.

```{r}
#| warning: false
#| fig-height: 6
#| fig-width: 6.36
par(mar = c(0, 0, 0, 0))
plot(st_geometry(africa) + c(50000,-50000), col = "#827e6c80", border = NA)
plot(st_geometry(africa) , col = "#5B89A3", border = NA, add = TRUE)
```

::: {.callout-tip}

## Astuce

On peut faire varier la transparence d'une couleur au fromat hexadecimal en ajouter un nombre de 00 √† 99 √† la fin du code. Par exemple `#827e6c60` applique une opacit√© de 60% √† la couleur `#827e6c`.

:::

## Cartographie th√©matique

Avec le package `sf`, il est (un peu) possible de r√©aliser des cartes th√©matiques. Rappelez-vous les couleurs de tout √† l'heure. Dans le cas o√π un seul attribut est s√©lectionn√©, une l√©gende est attribu√©e par d√©faut √† c√¥t√© de la carte. Ici, une donn√©e qualitative.

```{r}
plot(africa["region"])
```

Le positionnement de la l√©gende peut √™tre d√©fini par le param√®tre `key.pos` (1 = dessous, 2 = gauche, 3 = dessus and 4 = droite). Sa taille peut √©galement √™tre modifi√©e avec les param√®tres  `key.width` et `key.length`

```{r}
plot(africa["region"], key.pos = 1, key.length = 1)
```

Si on souhaite cartographier une variable quantitative, la palette par defaut est diff√©rente.

```{r}
plot(africa["pop"])
```

Grace au param√®tre `breaks`, il est possible de donner ses propres classes de valeur ou de donner une m√©thode de discr√©tisation (m√©thodes du package `classInt`).


```{r}
plot(africa["pop"], breaks = "jenks")
```

### Exports

Ici, on a affich√© toutes les cartes dans le document. Mais on peut √©galement choisir de les construire dans un format donn√© (pdf, svg, png, ps, etc.), ce qui peut √™tre utile pour les retravailler dans un logiciel de DAO. Par exemple, on peut √©crire : 


```{r}
#| output: false
svg("my_plot.svg")
plot(st_geometry(africa))
dev.off() 
```

### Bilan et limites

::: {.callout-important title="Que retenir ?"}

Les fonctions de cartographies dans les fonctionnalit√©s de base de `sf` sont tr√®s limit√©es. On ne peut pas, par exemple, dessiner des symboles proportionnels et leur l√©gende associ√©e. Si on veut aller plus loin, on a besoin d'un package sp√©cialis√© en repr√©sentations cartographiques. C'est √† ce besoin que r√©pond le package `mapsf`.

:::

# 2 - le package `mapsf`

`mapsf` permet de cr√©er la plupart des types de carte utilis√©s habituellement en cartographie statistique (cartes choropl√®thes, typologies, symboles proportionnels ou gradu√©s‚Ä¶).

<img src = "img/mapsf.png" width ="250px"></img>

Pour chaque type de carte, plusieurs param√®tres permettent de personnaliser la repr√©sentation cartographique. Ces param√®tres sont les m√™mes que ceux que l‚Äôon retrouve dans les logiciels de SIG ou de cartographie usuels. `mapsf` est le successeur du package cartography. Si vous avez l'habitude d'utiliser ce dernier, nous vous conseillons vivement de passer √† `mapsf`?

On charge le package

```{r}
library("mapsf")
```

## Documentation et support

De nombreux documents permettent de prendre en main ce package. 

- Le [site web](https://riatelab.github.io/mapsf)
- La [feuille de triche](https://raw.githubusercontent.com/riatelab/mapsf/master/vignettes/web_only/img/mapsf_cheatsheet.pdf)
- Le manuel [cartographie avec R](https://rcarto.github.io/cartographie_avec_r/))

## Afficher un fond de carte

La fonction `mf_map()` est la fonction centrale du package mapsf. Elle permet de r√©aliser la plupart des repr√©sentations usuelles en cartographie. Par d√©faut, elle permet d'afficher un fond de carte.


```{r}
#| warning: false
#| fig-height: 6
#| fig-width: 6.36
mf_map(x = africa, border = NA, col = NA)
mf_map(x = world, border = "white", col = "#CCCCCC50", lwd = 0.5, add = TRUE)
mf_map(x = africa, border = "white", col = "#6893d9", lwd = 0.5, add = TRUE)
mf_map(x = places, pch = 20, cex = .7, col = "darkred", add = TRUE)
mf_title(txt = "L'Afrique")
```

## Symboles proportionnels

Pour repr√©senter une donn√©e quantitative absolue (i.e. donn√©e de stock), on utilise la fonction `mf_map` avec le param√®tre `type = "prop"`

```{r}
#| warning: false
#| fig-height: 6
#| fig-width: 6.36
mf_map(x = africa, border = "white", lwd = 0.5)
mf_map(x = africa,
       var = "pop",
       type = "prop",
       border = "white",
       col = "#FF000080",
       leg_title = "Nombre d'habitants\nen 2020",
       inches	= 0.4)
mf_title(txt = "Population totale")
```

## Carte choropl√®the

## Carte de typologie

## Combinaisons

## Habillage et mise en page

# 3 - Cartographie avanc√©e

## Cartograms

Il existe plusieurs m√©thodes pour r√©aliser des cartogrammes.

### 1. Cartogrammes de Dorling

```{r}
library(cartogram)
```

```{r}
pop2020_dorling <- cartogram_dorling(
  africa[!is.na(africa$pop),],
  weight = "pop",
  k=2.5
  )
```

```{r}
mf_map(africa, col = "white", border= NA)
mf_map(pop2020_dorling, col = "#5B89A3", border= "white", add = TRUE)
mf_label(
  x = pop2020_dorling[order(pop2020_dorling$pop, decreasing = TRUE), ][1:10,],
  var = "name",
  col = "#5B89A3",
  overlap = FALSE, lines = FALSE,
  halo = TRUE,
  r = .15
)
mf_title("Population totale - Cartogramme de Dorling")
```

### 2. Les cartogrammes non continus

```{r}
afr_ncont <- cartogram_ncont(x = africa, weight = "pop", k = 1.2)
mf_map(africa, border = "white", lwd = 0.5,)
mf_map(afr_ncont, col = "#5B89A3", border= "white", add = TRUE)
mf_title("Population en Afrique - Cartogramme de Olson")
```

### 3. Cartogrammes continus

```{r}
africa[is.na(africa$pop),"pop"] <- 1
afr_cont <- cartogram_cont(x = africa,
                           weight = "pop",
                           itermax = 30)
mf_map(afr_cont, col = "#5B89A3", border= "white", add = FALSE)
mf_title("Population en Afrique - Cartogramme de Dougenik")
mf_inset_on(africa, cex = .2, pos = "topleft")
mf_map(africa, lwd = .5, border = "white")
mf_inset_off()
```

## Discontinuit√©s

???

## Lissages

???

## mapview

```{r}
library(mapview)
```

```{r}
mapview(africa) + mapview(st_centroid(africa))
```

## Leaflet

Leaflet est un package bas√© sur le JavaScript, permettant de faire de la cartographie interactive. 

```{r}
library(leaflet)
```

R√©alisation d'une primi√®re carte simple

```{r}
m = leaflet() %>% addTiles()
m
```

Zoom sur une localisation pr√©cise. 

```{r}
sfax <- c(10.760034694759957, 34.7407779744004)
m2 <- leaflet() %>% setView(lng = sfax[1], lat = sfax[2], zoom = 12) %>% 
  addTiles() 
m2
```

Ajout de g√©om√©tries

```{r}
africa_wgs84 <- st_transform(africa, 4326)
popup <- paste0("<b>",africa_wgs84$name,"</b><br/><b>Population: </b>", 
                africa_wgs84$pop)
m3 = leaflet() %>% 
  addTiles() %>% 
  addPolygons(data=africa_wgs84, weight = 2, fillColor = "yellow", popup= popup) %>%         
  addMarkers(data = st_centroid(africa_wgs84)) %>%  addMiniMap(position = "bottomright")
m3
```


## Au del√† de R

Avec Quarto, il est √©galement possible de cr√©er dans Rstudio, des cartes th√©matiques interactives pour le web. Pour celles et ceux qui le souhaitent, c'est ce que nous ferons vendredi matin. 

```{r}
#| echo: false
library("geojsonsf")
ojs_define(w = sf_geojson(world))
ojs_define(a = sf_geojson(africa))
```

```{ojs}
//| echo: false
viz = require("geoviz@0.6")
world = JSON.parse(w) 
africa = JSON.parse(a)
viewof k = Inputs.range([10, 100], {label: "Taille du plus gros cercle", value: 50, step: 1})
viewof dodge = Inputs.toggle({label: "√âcarter les cercles", value: false})
viewof leg_type = Inputs.radio(["separate", "nested"], {
  label: "Legende",
  value: "separate"
})

svg = viz.create({domain: africa, margin: 30, background:"#B5DFFD", width : 790, zoomable:true})
header = svg.header({text: "Population en Afrique, 2020", background_fill:"#3c799e", fill: "white" })
path = svg.path({datum: world, fill:"white", fillOpacity:0.3})
afr = svg.path({data: africa, fill:"#3c799e", strokeWidth:0.5, filter: svg.effect.shadow()})
bubble = svg.plot({
    type: "prop",
    id: "bubble",
    data: africa,
    var: "pop",
    fill:"red",
    fillOpacity: 0.8,
 tip: (d) =>
    `Il y a ${Math.round(
      d.properties.pop / 1000000
    )} million d'habitants en ${d.properties.name}`,
    dodge,
    k,
    strokeWidth:0.5,
    filter: svg.effect.shadow(),
    leg_pos: [60, 400],
    leg_type,
    leg_title: "Nombre d'habitants",
    leg_subtitle: "(en millions)",
    leg_values_round:0,
    leg_note: "Source: Banque mondiale, 2024",
    leg_values_factor: 1/1000000
})
svg.render({order: [header, path, afr, bubble]})
```