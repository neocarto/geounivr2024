---
title: "GEO UNIV'R Tunisie 2024"
subtitle: "Cartographier pour le Web avec `quarto` `{ojs}` et `geoviz`"
date: "`r Sys.Date()`"
author: "Nicolas Lambert, Elina Marveaux, Ronan Ysebaert"
format:
  html:
    embed-resources: true
    theme: yeti
    smooth-scroll: true
    fontsize: 0.9em
    toc: true
editor_options: 
  chunk_output_type: console
---

**L'objectif de ce TP est d'apprendre √† cr√©er des cartes interactives avec Quarto et la biblioth√®que JavaScript `geoviz`.**

```{ojs}
//| echo: false
chart = { 
  const k = width / 120;
  const r = d3.randomUniform(k, k * 4);
  const n = 4;
  const data = Array.from({length: 100}, (_, i) => ({r: r(), group: i && (i % n + 1)}));
  const height = width / 3;
  const color = d3.scaleOrdinal(d3.schemeTableau10);
  const context = DOM.context2d(width, height);
  const nodes = data.map(Object.create);

  const simulation = d3.forceSimulation(nodes)
    .alphaTarget(0.3)
    .velocityDecay(0.1)
    .force("x", d3.forceX().strength(0.01))
    .force("y", d3.forceY().strength(0.01))
    .force("collide", d3.forceCollide().radius(d => d.r + 1).iterations(3))
    .force("charge", d3.forceManyBody().strength((d, i) => i ? 0 : -width * 2 / 3))
    .on("tick", ticked);

  d3.select(context.canvas)
    .on("touchmove", event => event.preventDefault())
    .on("pointermove", pointermoved);

  invalidation.then(() => simulation.stop());

  function pointermoved(event) {
    const [x, y] = d3.pointer(event);
    nodes[0].fx = x - width / 2;
    nodes[0].fy = y - height / 2;
  }

  function ticked() {
    context.clearRect(0, 0, width, height);
    context.save();
    context.translate(width / 2, height / 2);
    for (let i = 1; i < nodes.length; ++i) {
      const d = nodes[i];
      context.beginPath();
      context.moveTo(d.x + d.r, d.y);
      context.arc(d.x, d.y, d.r, 0, 2 * Math.PI);
      context.fillStyle = color(d.group);
      context.fill();
    }
    context.restore();
  }

  return context.canvas;
}
```

# 1. Introduction

Avant de commencer, merci de regarder cette <a href ="https://neocarto.github.io/geounivr2024/VEN1_geoviz_intro/docs/index.html" target = "_BLANK">introduction</a> sur le Web, son histoire, ses langages et l'Observable JavaScript. C'est un pr√©requis pour comprendre la suite.

# 2. D√©marrer avec Quarto

## 2.1 Environnement logiciel.

Ce TP s'effectue avec le logiciel **Quarto**. Pour l'installer, vous pouvez utiliser le lien suivant :

[https://quarto.org/docs/get-started](https://quarto.org/docs/get-started/)

Puis, vous avez besoin d'une interface de d√©veloppement pour √©crire le code et visualiser le r√©sultat. Vous avez le choix.

![](img/ide.png)

Dans ce TP, nous privil√©gions l'utilisation du logiciel **Rstudio**. Pour le t√©l√©charger et l'installer, cliquez sur ce [lien](https://posit.co/download/rstudio-desktop/).

## 2.2 Cr√©er un document Quarto

-   Sur votre ordinateur, cr√©ez un dossier **TP_geoviz** √† l'emplacement de votre choix.
-   Ouvrez le logiciel RStudio
-   Cr√©ez un document Quarto (file \> New File \> Quarto Document)

![](img/create.png)

-   Cliquez sur "Create Empty Document" en bas √† gauche.
-   Mettez-vous en mode source

![](img/source.png)

Vous obtenez un fichier contenant les lignes suivantes :

```         
---
title: "Untitled"
format: html
editor: visual
---
```

-   Choisissez un titre
-   Sauvegardez le fichier **index.qmd** dans le dossier **TP_geoviz**.
-   Dans ce r√©pertoire, cr√©ez √©galement un sous r√©pertoire **data** pour stocker les donn√©es.

![](img/dossiers.png)

## 2.3 Rappel des principes

Dans ce TP, nous allons r√©aliser des cartes avec **Observable JavaScript** (ou **ojs**). Rappelons que l'ojs est un ensemble d'am√©liorations apport√©es √† JavaScript avec l'objectif d'en faire un langage d√©di√© √† la visualisation de donn√©es pour le web. Ce langage est compl√®tement int√©gr√© dans Quarto.

Les caract√©ristiques de l'ojs sont les suivantes :

-   Il s'agit de JavaScript + des biblioth√®ques pr√©charg√©es comme `Plot` & `d3js` üìä
-   Tout est r√©actif üî• et rejou√© en temps r√©el
-   L'ordre des cellules n'a pas d'importance ü§Ø
-   Chaque d√©but de ligne identifie une *cellule* ojs. Le nom de ces *cellules* doit √™tre unique pour l'ensemble du document.

Dans Quarto, toutes les instructions √† suivre s'√©crivent dans des chunks ojs

````         
``` {ojs}
```
````

::: {.callout-caution title="Attention"}
Attention, les chucks et les cellules sont deux concepts diff√©rents.
:::

Un chunk contenant une seule cellule

````         
``` {ojs}
sum = 10 + 10
```
````

Un chunk contenant trois cellules

````         
``` {ojs}
a = 10
b = 20
c = a * b
```
````

Un chunk contenant une seule cellule

````         
``` {ojs}
{
  // code JavaScript
  let a = 10
  let b = 20
  return a * b
}
```
````

Pour chaque *chunck*, vous pouvez d√©finir avec `echo` si vous souhaitez que le code s'affiche ou non dans votre notebook final. Avec `eval`, vous choisissez si le code doit s'ex√©cuter ou non.

````         
``` {ojs}
//| echo: false
//| eval: true
```
````

Le code en ligne vous permet √©galement d'ex√©cuter du code √† l'int√©rieur du texte markdown. La syntaxe du code en ligne est similaire √† celle des blocs de code, sauf que vous utilisez une seule coche (\`) au lieu de trois coche (\`\`\`)

```{ojs}
radius = 5
```

``` js
Le rayon du cercle est √©gal √† **``{ojs} radius``**
```

donne ceci :

Le rayon du cercle est √©gal √† **`{ojs} radius`**

Pour g√©n√©rer le document, il faut clicher sur le bouton `Render` ou utiliser le raccourci clavier **Ctrl+Shift+K**.

Une fois que vous avez cliqu√© sur *Render*, la page web s'affiche dans la panneau *Viewer* et un dossier **Docs** est cr√©e. Il contient le site web g√©n√©r√©.

Vous pouvez aussi cliquer sur l'ic√¥ne *voir dans une nouvelle fen√™tre* pour visualiser votre document dans votre navigateur web habituel.

![](img/view.png)

N'oubliez pas de sauvegarder votre document r√©guli√®rement (CTRL+S)

## 2.4 Documentation et exemples

Au fil de ce notebook, vous pourrez vous r√©f√©rer √† des √©l√©ments de documentation en cliquant sur cet ic√¥ne.

![](img/logo_doc.png)

Vous pourrez √©galement acc√©der √† des exemples p√©dagogiques et des d√©mos en ligne en cliquant sur celui-l√†.

![](img/logo_exemple.png)

# 3. Les donn√©es

Le jeu de donn√©es utilis√© est issu de la [banque mondiale](https://data.worldbank.org/indicator). Les donn√©es ont √©t√© mises en forme [ici](https://observablehq.com/@neocartocnrs/world-bank-data).

T√©l√©chargez les donn√©es et placez-les-les dans votre r√©pertoire **data**.

<a href = "https://github.com/neocarto/geounivr2024/raw/main/VEN1_geoviz_TP/data/worldbank.zip"><img src="img/download.png" height="50px"/><img /></a>

## 3.1 Import des donn√©es

Dans {ojs}, on importe les donn√©es avec l'instruction `FileAttachment()` <a href="https://github.com/observablehq/stdlib#file-attachments"><img src="img/logo_doc.png"/></a>.

Les donn√©es √©tant au format .zip, on √©crit :

```{ojs}
worldbank = FileAttachment("data/worldbank.zip").zip()
```

Ce fichier zip contient 3 fichiers.

```{ojs}
worldbank.filenames
```

Il existe plusieurs fonctions disponibles pour interpr√©ter les formats de donn√©es. La fonction `.csv()`permet d'importer des donn√©es csv. La fonction `.xlsx()` permet d'importer des tableurs excel. La fonction `.json()` permet d'importer des donn√©es au format JSON. Ici, on va donc cr√©er 3 jeux de donn√©es bien distincts.

-   Les donn√©es

```{ojs}
data = worldbank.file("data.csv").csv()
```

-   Les m√©tadonn√©es

```{ojs}
metadata = worldbank.file("metadata.csv").csv()
```

-   Le fond de carte (pays du monde)

```{ojs}
world = worldbank.file("world.json").json()
```

## 3.2 Visualiser les donn√©es attributaires

Pour visualiser un tableau de donn√©es, on peut utiliser l'instruction `Inputs.table()`.

```{ojs}
Inputs.table(data)
```

```{ojs}
Inputs.table(metadata)
```

On peut √©galement combiner cet affichage par table avec la fonction `Inputs.search()`.

```{ojs}
viewof search = Inputs.search(data, { query: "Tunisia" })
Inputs.table(search)
```

::: {.callout-tip collapse="true"}
## Astuce

Il est possible de combiner des chunks R et des chunks ojs grace √† l'instruction `ojs_define()`

Par exemple :

```{r}
# chunk r
datafromr <- read.csv("data/data.csv")
ojs_define(ojsdata = datafromr)
```

```{ojs}
// chunk ojs
Inputs.table(transpose(ojsdata))
```

Ca fonctionne √©galement avec des objets spatiaux. Mais pour cela, il faut proc√©der de fa√ßon un peu diff√©rente.

```{r}
#| output: false
# chunk r
library("sf")
library("geojsonsf")
geomfromr <- st_read("data/world.gpkg")
ojs_define(ojsgeom = sf_geojson(geomfromr))
```

```{ojs}
// chunk ojs
JSON.parse(ojsgeom) 
```

Voir d√©tail : [neocarto.github.io/docs/notebooks/ojsdefine/](https://neocarto.github.io/docs/notebooks/ojsdefine/)
:::

## 3.3 Visualiser des g√©om√©tries

Le fond de carte est au format geoJSON

```{ojs}
//| echo: false
world
```

Pour la visualiser, on a besoin d'importer une biblioth√®que de cartographie. Ici, on choisit la biblioth√®que `geoviz`

<a href = "https://riatelab.github.io/geoviz/" target = "_BLANK"><img src="img/geoviz.jpeg" width="350px"/></img></a>

On l'importe gr√¢ce √† l'instruction `require()`.

```{ojs}
viz = require("geoviz@0.6.0")
```

Pour visualiser simplement les g√©om√©tries avec une couleur al√©atoire, on tape :

```{ojs}
viz.path({data: world})
```

La carte est un peu grande. Nous pouvons la redimensionner en utilisant le param√®tre `svg_width`.

```{ojs}
viz.path({data: world, svg_width: 790})
```

::: {.callout-note title="Attention"}
L'attribut `svg_width` modifie les param√®tres du containeur SVG contenant la couche. Nous verrons plus tard comment fonctionnement les containers.
:::

## 3.4 Personnaliser l'affichage

La biblioth√®que `geoviz` n'est pas seulement un *viewer* de couches SIG. C'est un outil pour r√©aliser des cartes vectorielles. Avec `geoviz`, les cartes sont dessin√©es au format SVG. Il est donc possible d'utiliser tous les attributs SVG pour modifier la carte. A une nuance pr√®s. Le JavaScript ne support pas les noms de variable avec un tiret. Il est donc d'usage de convertir ce tiret en *camelCase*. Par exemple : `stroke-width` donnera `strokeWidth`.

Vous pouvez essayer :

-   `fill` : couleur de fond
-   `stroke` : couleur de contour
-   `strokeWidth` : √©paisseur des lignes
-   `fillOpacity` : opacit√© du fond
-   `strokeOpacity` : opacit√© du contour
-   `strokeDashArray` : pointill√©s (par exemple \[2,3\])

Bref, vous pouvez tout personnaliser comme sur une carte Inkscape ou Illustrator.

```{ojs}
viz.path({data: world, svg_width: 790, fill: "#d66bb3", strokeWidth:0.5})
```

Rappelez-vous qu'avec Observable, nous sommes dans un environnement interactif et r√©actif. On peut donc mettre en place des interactions pour personnaliser la carte. <a href="https://observablehq.com/documentation/inputs/overview"><img src="img/logo_doc.png"/></a>

```{ojs}
viewof colorfill = Inputs.color({label: "Fond", value: "#4682b4"})
viewof colorstroke = Inputs.color({label: "Contour", value: "#FF0000"})
viewof thickness = Inputs.range([0, 10], {step: 0.1, label: "Epaisseur", value:1})
```

```{ojs}
viz.path({data: world, svg_width:790, fill: colorfill, stroke: colorstroke, strokeWidth: thickness})
```

## 4. Logiques et principe de la biblioth√®que `geoviz`

### 4.1 Documentation et exemples

La documentation de `geoviz` est disponible √† l'adresse suivante : <a href="https://riatelab.github.io/geoviz/" target = "_BLANK">riatelab.github.io/geoviz</a>. Cliquez sur ce lien, et conservez pr√©cieusement la page pour pouvoir vous y r√©f√©rer √† tout moment.

<a href="https://riatelab.github.io/geoviz/" target = "_BLANK"><img src="img/geoviz_documentation.png" width="790px"/></a>

Pour comprendre comment fonctionne cette biblioth√®que, de nombreux exemples live sont √©galement disponibles sur la plateforme de notebooks Observable.

```{ojs}
//| echo: false
import { docs, previews } from "@neocartocnrs/geoviz-appendix"
previews(docs, 120)
```

### 4.2. Les `marks`

Au m√™me titre que l'instruction `path`, la biblioth√®que `geoviz` met √† disposition un certain nombre de `marks` permettant de constituer une carte.

Par exemple :

-   `circle` : des cercles <a href="https://riatelab.github.io/geoviz/global.html#circle" target = "_BLANK"><img src="img/logo_doc.png"/></a>
-   `square` : des carr√©s <a href="https://riatelab.github.io/geoviz/global.html#square" target = "_BLANK"><img src="img/logo_doc.png"/></a>
-   `halfcircle` : des demis cercles <a href="https://riatelab.github.io/geoviz/global.html#halfcircle" target = "_BLANK"><img src="img/logo_doc.png"/></a>
-   `spike` : des pointes <a href="https://riatelab.github.io/geoviz/global.html#spike" target = "_BLANK"><img src="img/logo_doc.png"/></a>
-   `graticule` : lignes de latitude et longitude <a href="https://riatelab.github.io/geoviz/global.html#graticule" target = "_BLANK"><img src="img/logo_doc.png"/></a>
-   `outline` : espace terrestre dans une projection donn√©e <a href="https://riatelab.github.io/geoviz/global.html#outline" target = "_BLANK"><img src="img/logo_doc.png"/></a>
-   `tile` : tuiles raster <a href="https://riatelab.github.io/geoviz/global.html#header" target = "_BLANK"><img src="img/logo_doc.png"/></a>
-   `header` : titre de la carte <a href="https://riatelab.github.io/geoviz/global.html#circle" target = "_BLANK"><img src="img/logo_doc.png"/></a>
-   `footer` : pied de page (sources) <a href="https://riatelab.github.io/geoviz/global.html#footer" target = "_BLANK"><img src="img/logo_doc.png"/></a>
-   `north`: fleche nord <a href="https://riatelab.github.io/geoviz/global.html#north" target = "_BLANK"><img src="img/logo_doc.png"/></a>
-   `scalebar` : barre d'√©chelle <a href="https://riatelab.github.io/geoviz/global.html#scalebar" target = "_BLANK"><img src="img/logo_doc.png"/></a>
-   `text` : textes et labels <a href="https://riatelab.github.io/geoviz/global.html#text" target = "_BLANK"><img src="img/logo_doc.png"/></a>

On peut appeler ces `marks` directement.

```{ojs}
viz.circle({ r: 40, fill: "#38896F" })
```

```{ojs}
viz.square({ side: 60, fill: "#38896F", angle: 45 })
```

Si on utiliser l'attribut `data`, alors, les marques sont plac√©es au centre des unit√©s g√©ographiques. Par exemple

```{ojs}
viz.square({ data: world, svg_width: 790, side: 6, fill: "#38896F", angle: 45 })
```

```{ojs}
viz.text({ data: world, svg_width: 785, text: "ISO3", fill: "#38896F" })
```

Mais la plupart du temps, on utilisera ces `marks` √† l‚Äôint√©rieur de conteneurs dans lesquels nous pourrons les superposer.

### 4.3. Les `conteneurs`

Dans `geoviz`, pour combiner diff√©rentes couches sur une carte, vous devez cr√©er un conteneur SVG <a href="https://observablehq.com/@neocartocnrs/containers"><img src="img/logo_exemple.png" target="_BLANK"/></a>. Ce conteneur est cr√©√© avec l'instruction `create()` <a href="https://riatelab.github.io/geoviz/global.html#create"  target = "_BLANK"><img src="img/logo_doc.png"/></a>. Il peut ensuite √™tre affich√© √† l'aide de la fonction `render()` <a href="https://riatelab.github.io/geoviz/global.html#render"  target = "_BLANK"><img src="img/logo_doc.png"/></a>.

::: callout-tip
## Astuce

Pour cr√©er la carte dans une seule cellule, on met les instruction entre accolades
:::

```{ojs}
{
  let svg = viz.create()
  svg.path({data:world})
  return svg.render()
}
```

Pour bien fonctionner, le conteneur a besoin que vous d√©finissiez une `projection` et/ou une emprise g√©ographie (`domain`).

::: callout-note
Notez que dor√©navant, c'est au niveau de la fonction `create()` que nous allons d√©finir la taille de la carte.
:::

Recommen√ßons.

```{ojs}
{
  let svg = viz.create({domain: world, width: 790})
  svg.path({data:world, fill :"#38896F"})
  return svg.render()
}
```

## 4.4 Les projections

Dans l‚Äô√©cosyst√®me de `d3js` et `geoviz`, on utilise des fonctions de projections bien sp√©cifiques d√©di√©es √† la repr√©sentation de donn√©es. elles sont r√©parties dans 3 biblioth√®ques : `d3-geo` <a href="https://github.com/d3/d3-geo" target = "_BLANK"><img src="img/logo_doc.png"/></a>, `d3-geo-projection` <a href="https://github.com/d3/d3-geo-projection" target = "_BLANK"><img src="img/logo_doc.png"/></a> et `d3-geo-polygon` <a href="https://github.com/d3/d3-geo-polygon" target = "_BLANK"><img src="img/logo_doc.png"/></a>.

On les charge de la fa√ßon suivante :

```{ojs}
d3 = require("d3", "d3-geo", "d3-geo-projection", "d3-geo-polygon")
```

Le principe est qu'on utilise en entr√©e toujours des g√©om√©tries au format lat/lon qui sont projet√©es √† la vol√©e au moment de l'affichage.

Par exemple :

```{ojs}
{
  let svg = viz.create({domain: world, width: 790, projection: d3.geoNaturalEarth1()})
  svg.path({data:world, fill :"#38896F"})
  return svg.render()
}
```

::: callout-note
Notez que vous auriez aussi simplement pu √©crire :

``` js
viz.path({data:world, fill :"#38896F", svg_width: 790, svg_projection: d3.geoNaturalEarth1()})
```
:::

Avec les containers, on peut maintenant empiler les couches. En jouant avec les `marks` et les attributs SVG, on peut r√©aliser de tr√®s beaux *templates* cartographiques.

```{ojs}
{
  let svg = viz.create({width: 790, projection: d3.geoAitoff() })
  svg.outline()
  svg.graticule({stroke: "white", step: 40})
  svg.path({datum:world, fill :"white", fillOpacity:0.3})
  svg.header({text: "Hello World"})
  return svg.render()
}
```

Grace aux `Inputs`, vous pouvez vous amuser √† visualiser diff√©rentes projections.

```{ojs}
projections = [
  { name: "Interrupted Sinusoidal", proj: d3.geoInterruptedSinusoidal() },
  { name: "Gingery", proj: d3.geoGingery() },
  { name: "Baker", proj: d3.geoBaker() },
  { name: "PolyhedralWaterman", proj: d3.geoPolyhedralWaterman()  },     
]
```

```{ojs}
viewof projection = Inputs.select(projections, {
  label: "Projection",
  format: (x) => x.name
})
```

```{ojs}
{
  let svg = viz.create({width: 790, projection: projection.proj})
  svg.graticule({stroke :"#38896F", strokeWidth: 1.5, strokeDasharray:null, step:40, clipPath : svg.effect.clipPath()})
  svg.path({datum:world, fill :"#38896F"})
  svg.outline({stroke :"#38896F", fill:"none", strokeWidth: 2})
  return svg.render()
}
```

## 4.5 Zoom et Pan

Dans le conteneur, avec l'attribut `zoomable` <a href="https://observablehq.com/@neocartocnrs/zooming"  target = "_BLANK"><img src="img/logo_exemple.png"/></a>, on va aussi pouvoir dire si on veut que la carte soit zoomable.

Par exemple :

```{ojs}
{
  let svg = viz.create({width: 790, projection: d3.geoBertin1953(), zoomable:true })
  svg.outline()
  svg.graticule({stroke: "white"})
  svg.path({datum:world, fill :"white", fillOpacity:0.3})
  return svg.render()
}
```

Avec une projection orthographique et l'attribut`zoomable = "versor"`, vous pouvez aussi jouer sur le centre de projection pour faire tourner le globe.

```{ojs}
{
  let svg = viz.create({width: 790, projection: d3.geoOrthographic().rotate([-30, -30]), zoomable:"versor" })
  svg.outline()
  svg.graticule({stroke: "white"})
  svg.path({datum:world, fill :"white", fillOpacity:0.3})
  return svg.render()
}
```

Notez que `"versor"` s'applique sur n'importe quelle projection, ce qui peut √™tre d√©routant, mais aussi bien utile pour comprendre vraiment comment fonctionnent les projections cartographiques.

```{ojs}
{
  let svg = viz.create({width: 790, projection: d3.geoEckert3(), zoomable:"versor" })
  svg.outline()
  svg.graticule({stroke: "white"})
  svg.path({datum:world, fill :"white", fillOpacity:0.3})
  return svg.render()
}
```

## 4.6 Tuiles raster

Comme les autres `marks`, les tuiles raster <a href="https://riatelab.github.io/geoviz/global.html#tile" target = "_BLANK"><img src="img/logo_doc.png"/></a> <a href="https://observablehq.com/@neocartocnrs/tile-mark" target = "_BLANK"><img src="img/logo_exemple.png"/></a> sont √©galement zoomable.

Les styles disponibles par d√©faut sont : "openstreetmap", "opentopomap", "worldterrain", "worldimagery", "worldStreet", "worldphysical", "shadedrelief", "stamenterrain", "cartodbvoyager", "stamentoner","stamentonerbackground","stamentonerlite","stamenwatercolor","hillshade","worldocean","natgeo" et "worldterrain"

::: callout-caution
## Attention

Pour utiliser la mark `tile`, vous devez forc√©ment utiliser la projection "mercator"
:::

```{ojs}
{
  let svg = viz.create({width: 790, projection: "mercator", zoomable:true })
  svg.tile({url:"natgeo"})
  svg.path({datum:world, fill :"none", stroke:"white"})
  return svg.render()
}
```

## 4.7 Infobulles

Avec `geoviz`, vous pouvez ajouter des infobulles <a href="https://observablehq.com/@neocartocnrs/tooltip" target = "_BLANK"><img src="img/logo_exemple.png"/></a> sur n'importe quel objet. En utilisant `tip: true`, tous les champs sont affich√©s.

```{ojs}
{
  let svg = viz.create({width: 790, projection: d3.geoNaturalEarth1()})
  svg.path({data:world, fill :"#38896F", stroke:"white", strokeWidth:0.3, tip:true})
  return svg.render()
}
```

Mais tout est personnalisable

```{ojs}
{
  let svg = viz.create({width: 790, projection: d3.geoNaturalEarth1()})
  svg.path({data:world, fill :"#38896F", stroke:"white", strokeWidth:0.3, tip: `Ce pays est $NAMEfr et son code est : $ISO3`})
  return svg.render()
}
```

## 5 Cartographie statistique

### 5.1. La jointure

La premi√®re chose √† faire ici est de r√©aliser une jointure entre les g√©om√©tries et les donn√©es statistiques import√©es en haut de ce notebook depuis un fichier zip.

Examinons √† nouveau le tableau de donn√©es.

```{ojs}
Inputs.table(data)
```

Le tableau contient des informations √† plusieurs dates. Il y a donc plusieurs fois le m√™me identifiant (id) dans le tableau de donn√©es. La premi√®re √©tape consiste donc √† s√©lectionner une ann√©e.

En JavaScript, on utilise l'instruction `filter`.

```{ojs}
data2020 = data.filter(d => d.year == 2020)
Inputs.table(data2020)
```

::: callout-tip
## Astuce

Manipuler un tableau de donn√©es en JavaScript quand on l'habitude de le faire en R peut √™tre d√©routant. Mais vous avez la possibilit√© d'utiliser la biblioth√®que `arquero` qui ressemble beaucoup √† `dplyr`.

Plus d'informations ici : [observablehq.com/\@neocartocnrs/les-tableaux-de-donnees](https://observablehq.com/@neocartocnrs/les-tableaux-de-donnees?collection=@neocartocnrs/observable-cest-quoi)
:::

Pour r√©aliser la jointure, on utilise l'instruction `viz.tool.merge()` <a href="https://riatelab.github.io/geoviz/global.html#tool/merge" target = "_BLANK"><img src="img/logo_doc.png"/></a>.

```{ojs}
jointure = viz.tool.merge({geom: world, geom_id: "ISO3", data: data2020, data_id:"id"})
```

La fonction renvoie le r√©sultat de la jointure mais √©galement un diagnostic pour √©valuer la qualit√© de cette jointure.

```{ojs}
//| echo : false
jointure
```

Le nouveau fond de carte est donc :

```{ojs}
world2020 = jointure.featureCollection
```

### 5.2. Symboles proportionnels

Pour repr√©senter des donn√©es quantitatives absolues, on utilise en cartographie des symboles qu'on fait varier de fa√ßon proportionnelle. Pour cela, on utilisera la fonction `viz.plot()` <a href = "https://riatelab.github.io/geoviz/global.html#plot" target = "_BLANK"><img src="img/logo_doc.png"/></a> avec `type: "prop"` <a href = "https://riatelab.github.io/geoviz/global.html#plot/prop" target = "_BLANK"><img src="img/logo_doc.png"/></a>. C'est un peu la m√™me logique qu'avec `r::mapsf`.

La carte peut se dessiner comme ceci :

```{ojs}
{
let svg = viz.create({width: 790, domain: world2020})
svg.plot({type: "base", data: world2020, fill: "#CCC"})
svg.plot({type: "prop", data: world2020, var: "pop", fill:"#d47988", leg_pos:[10, 200]})
return svg.render()
}
```

### 5.3. Typologies

Pour r√©aliser des typologies, on utilise √©galement la fonction `plot()` avec `type: "typo"` <a href = "https://riatelab.github.io/geoviz/global.html#plot/typo" target = "_BLANK"><img src="img/logo_doc.png"/></a>

```{ojs}
{
let svg = viz.create({width: 790, domain: world2020})
svg.plot({type: "typo", data: world2020, var: "region", leg_pos:[10, 100]})
return svg.render()
}
```

De nombreuses palettes de couleurs sont disponibles dans dicopal <a href = "https://observablehq.com/@neocartocnrs/dicopal-library" target = "_BLANK"><img src="img/logo_exemple.png"/></a>

### 5.4 Carte choropl√®the

Pour r√©aliser une carte choropl√®the, on utilisera le `type: "choro"` <a href = "https://riatelab.github.io/geoviz/global.html#plot/choro" target = "_BLANK"><img src="img/logo_doc.png"/></a>

```{ojs}
{
let svg = viz.create({width: 790, domain: world2020})
svg.plot({type: "choro", data: world2020, var: "gdppc", leg_pos:[10, 100]})
return svg.render()
}
```

Avec `method`, vous pouvez changer la m√©thode de discr√©tisation : 'quantile', 'q6', 'equal', 'jenks', 'msd', 'geometric', 'headtail', 'pretty', 'arithmetic' ou 'nestedmeans'.

Avec `nb`, vous pouvez changer le nombre de classes.

Avec `colors`, vous pouvez changer la palette.

### 5.5 Combinaisons

Avec les types "propchoro" <a href = "https://riatelab.github.io/geoviz/global.html#plot/propchoro" target = "_BLANK"><img src="img/logo_doc.png"/></a> et "proptypo" <a href = "https://riatelab.github.io/geoviz/global.html#plot/proptypo" target = "_BLANK"><img src="img/logo_doc.png"/></a> vous pouvez faire des combinaisons graphiques.

Par exemple

```{ojs}
{
let svg = viz.create({width: 790, domain: world2020})
svg.plot({type: "propchoro", data: world2020, var1: "pop", var2: "gdppc"})
return svg.render()
}
```

### 5.6 Tout est param√©trable/configurable

Rappelez-vous √©galement que nous sommes dans un environnement r√©actif et que vous pouvez proposer des interactions pour modifier la carte.

```{ojs}
viewof title = Inputs.textarea({label: "Titre de la carte", placeholder: "Titre..."})
viewof k = Inputs.range([10, 70], {step: 1, label: "Rayon du plus grand cercle"})
viewof toggle = Inputs.toggle({label: "√âcarter les cercles ?", value: false})
```

```{ojs}
{
let svg = viz.create({width:790, domain: world2020})
svg.path({datum: world2020, fill:"#CCC"})
svg.plot({type:"prop", data: world2020, var: "pop", k:k, fill:"#e02d51", dodge: toggle, leg_pos:[10, 200] })
svg.header({text: title })
return svg.render()
}
```

Tout est compl√®tement param√©trable.

```{ojs}
{
  let svg = viz.create({ projection: d3.geoOrthographic().rotate([-50,-50]), zoomable: "versor", width:790 });
  svg.plot({ type: "outline", fill: svg.effect.radialGradient() });
  svg.plot({
    type: "graticule",
    stroke: "white",
    step: 40,
    strokeWidth: 2,
    strokeOpacity: 0.3
  });
  svg.plot({ type: "typo", data: world2020, var: "region", stroke: "none", legend: false });
  svg.plot({
    type: "prop",
    symbol: "square",
    data: world2020,
    var: "pop",
    fill: "red",
    fillOpacity:0.8,
    leg_type: "nested",
    leg_values_factor: 1 / 1000000,
    leg_pos: [20, 20],
    leg_frame:true,
    leg_title: "Nombre d'habitants",
    leg_subtitle: "(en millions)",
    tip: `$name ($ISO3)`,
    tipstyle: {
    fontSize: 20,
    fill: "white",
    background: "#38896F",
  }
  });
  return svg.render();
}
```

## 6. R√©alisation d'une carte anim√©e

On importe un widget depuis la plateforme de notebooks Observable.

```{ojs}
import {Scrubber} from "@mbostock/scrubber"
```

Puis on r√©alise la carte

```{ojs}
// Inputs
viewof annees = Scrubber(d3.range(1960,2023), {autoplay: false})
// Tri des donn√©es
mydata = data.filter(d => d.year == annees)
mybasemap = viz.tool.merge({geom: world, geom_id: "ISO3", data: mydata, data_id:"id"}).featureCollection
// Carte
{
  let svg = viz.create({width:790, projection: d3.geoBertin1953()})
  svg.outline()
  svg.graticule({stroke: "white", step: 40})
  svg.path({datum: world, fill:"white", fillOpacity:0.3})
  svg.header({text: `Population en ${annees}`})
  svg.plot({type:"prop", data: mybasemap,  var: "pop", fill:"red", fixmax: 1417173173, tip:`$name\n$pop`})
  return svg.render()
}
```

## 7. Les dashboards

Depuis la version 1.4, Quarto propose des mises en page √† la fa√ßon de *dashboards*. Tout ce que nous avons vu pr√©c√©demment est donc facilement mobilisable pour r√©aliser une application compl√®te. Quelques exemples sont disponibles sur le site de Quarto.

<a href = "https://quarto.org/docs/dashboards/examples/" target = "_BLANK"><img src="img/dashboards.png" width="790"/></img></a>

Voir un exemple ici : [neocarto.github.io/geounivr2024/VEN1_geoviz_dashboard](https://neocarto.github.io/geounivr2024/VEN1_geoviz_dashboard/index.html)

## 8. Aller plus loin

<a href = "https://observablehq.com/collection/@neocartocnrs/observable-cest-quoi" target = "_BLANK"><img src="img/obsgeo.png"/></img></a>
